#!/usr/bin/env python

import rospy
import dubins
import numpy as np
from geometry_msgs.msg import PoseStamped, PoseArray
from nav_msgs.msg import Odometry, OccupancyGrid
from visualization_msgs.msg import Marker
import rospkg
import time, os
from tf.transformations import quaternion_matrix, euler_from_quaternion
from utils import LineTrajectory

from visualization_tools import *
import cartography


class Point(object):
    """ Helper class for points to be able to create PoseArrays
    """
    def __init__(self, u, v):
        self.x = u
        self.y = v

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

class PathPlan(object):
    """ Listens for goal pose published by RViz and uses it to plan a path from
    current car pose.
    """
    def __init__(self):
        self.odom_topic = rospy.get_param("~odom_topic", "/odom")
        #self.odom_topic = "/odom"
        
        self.map = cartography.Map("/map", 0.2)
        # self.map_sub = rospy.Subscriber("/map", OccupancyGrid, self.map_cb)



        self.trajectory = LineTrajectory("/planned_trajectory")
        self.goal_sub = rospy.Subscriber("/move_base_simple/goal", PoseStamped, self.goal_cb, queue_size=10)
        
        self.traj_pub = rospy.Publisher("/trajectory/current", PoseArray, queue_size=10)
        # self.traj_constructor_pub = rospy.Publisher("/trajectory/current", PoseArray, queue_size=10)

        self.odom_sub = rospy.Subscriber(self.odom_topic, Odometry, self.odom_cb)
        ### TWEAKABLE ###

        # The maximum distance between trajectory points (used by the dubins curve configuration generator)
        self.step_size = 0.5
        # The maximum turning radius of the produced solution
        self.turning_radius = 0.4

        # maximum number of samples generated by the RRT algorithm
        self.num_samples = 500

        
        # Declare vars
        self.resolution = None
        self.width = None
        self.height = None
        self.origin = None
        self.grid = None
        self.map_resolved = False
        self.start_point = None
        self.start_resolved = False
        self.end_point = None
        self.end_resolved = False
        self.graph = None

        # self.plan_path(0, 0, 0)
                                                 
    # def map_cb(self, msg):
    #     data = np.array(msg.data, np.double)
    #     data = np.where(data < 0, 100, data)
    #     data = data/100.0
    #     data = np.clip(data, 0, 1)
    #     data = np.where(data > 0.3, 1, 0)
    #     self.resolution = float(msg.info.resolution)
    #     self.width = int(msg.info.width)
    #     self.height = int(msg.info.height)


        
    #     # position of the map_grid origin wrt to the /map frame
    #     origin_p = msg.info.origin.position

    #     # map_grid is rotated around map_grid origin, AFTER it is translated
    #     origin_o = msg.info.origin.orientation
    #     origin_o = euler_from_quaternion((origin_o.x, origin_o.y,
    #                                      origin_o.z, origin_o.w))
        
    #     # the real world pose of the origin of the map [m, m, rad]
    #     self.origin = (origin_p.x, origin_p.y, origin_o[2])
    #     self.grid = np.reshape(data, (self.height, self.width))
        

    #     if not self.map_resolved:
    #         rospy.loginfo("Map Initialized")
    #         # print('width', self.width)
    #         # print('height', self.height)
    #         # # print('resolution', self.resolution)

    #         # # print('pixel origin', self.real2pix((0,0,0)))
    #         # # print('pixel 1,1', self.real2pix((1,1,0)))

    #         # n = 1000
    #         # points = np.zeros([2,n])

    #         # for i in range(n):
    #         #     points[:,i] = self.real2pix(self.sample())

    #         # print(max(points[0,:]))
    #         # print(min(points[0,:]))
    #         # print(max(points[1,:]))
    #         # print(min(points[1,:]))

    #     self.map_resolved = True

    def odom_cb(self, msg):
        x = msg.pose.pose.position.x
        y = msg.pose.pose.position.y
        q = msg.pose.pose.orientation
        # Pull rotation around z
        _, _, th = euler_from_quaternion([q.x, q.y, q.z, q.w])
        self.start_point = (x, y, th)
        

        if not self.start_resolved:
            rospy.loginfo("Start Initialized")
        self.start_resolved = True

    def goal_cb(self, msg):
        x = msg.pose.position.x
        y = msg.pose.position.y
        q = msg.pose.orientation
        # Pull rotation around z
        _, _, th = euler_from_quaternion([q.x, q.y, q.z, q.w])
        self.end_point = (x, y, th)

        if not self.end_resolved:
            rospy.loginfo("End Initialized")
        self.end_resolved = True


        self.plan_path(0,self.end_point,0)
        
    def plan_path(self, start_point, end_point, map):
        if not self.end_resolved or not self.start_resolved or not self.map.resolved:
            return
        rospy.logwarn("Beginning Path Planning")
        
        # rate = rospy.Rate(10)
        
        # graph maps poses to [parent, path_to_parent, edge_length, distance]
        graph = {}
        # the root of the tree
        graph[self.start_point] = [None, None, 0, 0]

        # Check if a straight line would solve the optimization
        straight_path, path_length = self.steer(self.start_point, self.end_point)
        
        if not self.map.is_path_blocked(straight_path):
            # the straight-line case
            graph[self.end_point] = [self.start_point, straight_path, path_length, path_length]
            rospy.logwarn("Straight line works")
        else:
            rospy.logwarn("Obstacles detected, running RRT")
            # Run a discrete number of samples
            for i in range(self.num_samples):
                # get a random point on the map that is not in collision
                z_rand = tuple( self.map.random_point_clear() )
                
                # Find nearest vertex to new point
                z_nearest = self.nearest(graph, z_rand)
                # Compute path from newest point to nearest one
                new_path, path_length = self.steer(z_nearest, z_rand)

                # Check for collisions along path
                if self.map.is_path_blocked(new_path):
                    # bad node, try again
                    # TODO: catch this case in a way that does not change the size of the tree
                    continue

                # End Node: [Initial Node, path]
                parent_distance = graph[z_nearest][3]
                graph[z_rand] = [z_nearest, new_path, path_length, parent_distance+path_length]
                


                # check if the line segment from new vert to goal collides
                end_run, end_length = self.steer(z_rand, self.end_point)
                end_distance = parent_distance+path_length+end_length

                if self.map.is_path_blocked(end_run) and \
                        (not end_point in graph.keys() or \
                        graph[end_point][3] > end_distance):
                    # rospy.logwarn("Good path to end point")
                    graph[self.end_point] = [z_rand, end_run, end_length, end_distance]
                

                # VisualizationTools.plot_tree(self.graph, self.traj_pub, frame='/map')
                # rate.sleep()

        # Search backward for the shortest path
        # Add end point to temp trajectory
        curr = self.end_point
        curr_x, curr_y, curr_th = self.end_point
        traj = np.array([[curr_x, curr_y, curr_th]])
        # Iterate backward through parents to find the total path
        
        try:
            assert( graph[curr] != None)
        except:
            rospy.logerr("No path produced by RRT")
            return


        summed_path_length=0
        while curr != self.start_point:
            # print(self.graph)
            c_parent, c_path, l,total_path = graph[curr]
            # Add elements to the temp trajectory once found
            c_path = np.array(c_path)
            traj = np.concatenate((c_path, traj))
            curr = c_parent

            summed_path_length += l

        rospy.logwarn(summed_path_length)
        rospy.logwarn(graph[self.end_point][3])

        # Create the trajectory by adding all points
        self.trajectory.clear()
        for el in traj:
            self.trajectory.addPoint(Point(el[0], el[1]))
        
        # visualize trajectory Markers
        self.trajectory.publish_viz()
        
        # publish trajectory
        self.traj_pub.publish(self.trajectory.toPoseArray())


    # def sample(self):
    #     """
    #         sample randomly from the real world space. 
    #         returns (x, y, th) in (m, m, rad)
    #     """

    #     #TODO: make sure this distribution actually covers the map nicely
    #     th = np.random.random_sample()*2*np.pi
    #     x,y = self.pix2real( np.random.uniform(2, (self.width-1, self.height-1)) )
    #     return (x, y, th)

    def steer(self, near, rand):
        """
            returns a smoothed set of poses between two endpoints
            self.step_size is the distance between these interim poses
            self.turning_radius is the max turning radius of the car

            near and rand are both poses in the form (x,y,theta)
        """
        #Use dubins curves
        path = dubins.shortest_path(near, rand, self.turning_radius)
        configurations, lengths = path.sample_many(self.step_size)

        
        return (configurations, lengths[-1])
    
    # def collision_free(self, path):
    #     # check if each element of the path is in the occupancy grid
        
    #     for el in path:
    #         if self.map.is_collision(el):
    #             return False
    #     return True

    # def collision(self, point):
    #     u, v = self.real2pix(point)
    #     return u < 0 or v < 0 or u >= self.width or v >= self.height or self.grid[v, u] ==  1.0
    #     # return self.grid[v, u] ==  1.0

    def nearest(self, graph, rand):
        assert( len(graph) > 0 )
        
        # find distance of each point in graph to rand point
        gr = graph.keys()
        paths = np.array([])
        for n in gr:
            path_len = dubins.shortest_path(n, rand, self.turning_radius).path_length()
            paths = np.append(paths, path_len + graph[n][3])
        # Use np.argmin to find smallest dist
        # print("near res", gr[np.argmin(paths)])
        return gr[np.argmin(paths)]

    # def real2pix(self, point):
    #     x, y, th = point
    #     # multiply (x, y) * self.resolution
    #     # apply rotation and translation of self.origin.orientation and self.origin.position
    #     ang = -self.origin[2]
    #     x_map_to_point = np.array([x - self.origin[0], y - self.origin[1]])


    #     rot = np.array([[np.cos(ang), -np.sin(ang)], [np.sin(ang), np.cos(ang)]])
    #     #y = -y
    #     # rot = np.append(rot, np.array([[-self.origin[0], -self.origin[1]]]).T, 1)
    #     # print("append arr", np.array([[self.origin[0], self.origin[1]]]).T)
    #     # rot = np.append(rot, np.array([[0, 0, 1]]), 0)
    #     # print("rot", rot)

    #     # p_matrix = np.array([[x, y, 1]]).T
    #     rotated = np.dot(rot, x_map_to_point.T)
    #     rotated = rotated/self.resolution
    #     return (int(rotated[0]), int(rotated[1]))

    # def pix2real(self, pix):
    #     """
    #     expects pix to be a tuple of (x,y)
    #     returns (x,y) in meters in the /map frame
    #     """
    #     ang = self.origin[2]
    #     rot = np.array([[np.cos(ang), -np.sin(ang)], [np.sin(ang), np.cos(ang)]])

    #     p = np.dot(rot, np.array(pix).T * self.resolution)
        
    #     return (p[0]+self.origin[0], p[1]+self.origin[1])
                                
if __name__=="__main__":
    rospy.init_node("path_planning")
    pf = PathPlan()
    rospy.spin()
